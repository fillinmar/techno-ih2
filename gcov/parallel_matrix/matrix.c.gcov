        -:    0:Source:/home/fillinmar/semc++/techno-ih2/src/parallel_matrix/matrix.c
        -:    0:Graph:../../build/src/parallel_matrix/CMakeFiles/parallel_matrix.dir/matrix.c.gcno
        -:    0:Data:../../build/src/parallel_matrix/CMakeFiles/parallel_matrix.dir/matrix.c.gcda
        -:    0:Runs:2
        -:    1://
        -:    2:// Created by fillinmar on 29.03.2021.
        -:    3://
        -:    4:
        -:    5:#include "matrix.h"
        -:    6:#include <stdlib.h>
        -:    7:#include <stdio.h>
        -:    8:#include <sys/mman.h>
        -:    9:#include <sys/wait.h>
        -:   10:#include <unistd.h>
        -:   11:
        6:   12:int make_mirror_matrix_with_file(Matrix *matrix, const char *filename) {
        6:   13:    if (!filename)
    #####:   14:        return 1;
        6:   15:    int *index_of_diagonal = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,
        -:   16:                                  MAP_SHARED | MAP_ANONYMOUS, -1, 0);
        6:   17:    if (!index_of_diagonal) {
    #####:   18:        return 1;
        -:   19:    }
        6:   20:    *index_of_diagonal = matrix->horizontal;
        -:   21:
        6:   22:    int *count_of_passed = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,
        -:   23:                                MAP_SHARED | MAP_ANONYMOUS, -1, 0);
        6:   24:    if (!count_of_passed) {
    #####:   25:        return 1;
        -:   26:    }
        6:   27:    *count_of_passed = 0;
        -:   28:
        -:   29:
        6:   30:    int size_of_martix = matrix->horizontal * matrix->vertical * sizeof(int);
        -:   31:
        6:   32:    int *mirror_paral_matrix = mmap(NULL, size_of_martix, PROT_READ | PROT_WRITE,
        -:   33:                                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
        6:   34:    if (!mirror_paral_matrix) {
    #####:   35:        return 1;
        -:   36:    }
        -:   37:
        6:   38:    int count_of_process = matrix->vertical / 2 + matrix->vertical % 2;
        6:   39:    int *pids = (int *) calloc(count_of_process, sizeof(int));
        6:   40:    if (!pids)
    #####:   41:        return 1;
        6:   42:    int middle_of_array = matrix->vertical / 2;
        -:   43:
       24:   44:    for (int i = 0; i < count_of_process; ++i) {
       18:   45:        pids[i] = fork();
       36:   46:        if (pids[i] == -1) {
    #####:   47:            printf("Fork failed\n");
    #####:   48:            if (munmap(mirror_paral_matrix, size_of_martix))
    #####:   49:                return 1;
        -:   50:        }
       36:   51:        if (pids[i] == 0) {
       18:   52:            if (matrix->vertical % 2 == 1 && i == count_of_process - 1) {
       30:   53:                for (int j = 0; j < matrix->horizontal / 2 - 1; ++j) {
       24:   54:                    mirror_paral_matrix[middle_of_array * matrix->horizontal + j] = matrix->array[middle_of_array][
       24:   55:                            matrix->horizontal - j - 1];
       24:   56:                    mirror_paral_matrix[matrix->horizontal * matrix->vertical - 1 - j -
       24:   57:                                        *count_of_passed] = matrix->array[middle_of_array][j];;
        -:   58:                }
        6:   59:                mirror_paral_matrix[middle_of_array * matrix->horizontal + matrix->horizontal / 2 -
        6:   60:                                    1] = matrix->array[middle_of_array][
        6:   61:                        matrix->horizontal / 2 - 1];
        6:   62:                mirror_paral_matrix[middle_of_array * matrix->horizontal +
        6:   63:                                    matrix->horizontal / 2] = matrix->array[middle_of_array][matrix->horizontal / 2];
        -:   64:
        -:   65:            } else
      132:   66:                for (int j = 0; j < matrix->horizontal; ++j) {
      120:   67:                    if (j < *index_of_diagonal - 2 || j >= *index_of_diagonal) {
       96:   68:                        mirror_paral_matrix[(*count_of_passed) + j] = matrix->array[i][matrix->horizontal * 2 - j - 1];
       96:   69:                        mirror_paral_matrix[matrix->horizontal * matrix->vertical - 1 - j -
       96:   70:                                            *count_of_passed] = matrix->array[i][j];
        -:   71:                    } else {
       24:   72:                        mirror_paral_matrix[(*count_of_passed) + j] = matrix->array[i][j];
       24:   73:                        mirror_paral_matrix[matrix->horizontal * matrix->vertical - 1 - j -
       24:   74:                                            *count_of_passed] = matrix->array[i][
       24:   75:                                matrix->horizontal * 2 -
        -:   76:                                j -
        -:   77:                                1];
        -:   78:                    }
        -:   79:
        -:   80:                }
       18:   81:            *index_of_diagonal = *index_of_diagonal - 2;
       18:   82:            *count_of_passed = *count_of_passed + matrix->horizontal;
       18:   83:            exit(EXIT_SUCCESS);
        -:   84:        }
        -:   85:    }
        -:   86:
       24:   87:    for (int i = 0; i < count_of_process; ++i) {
        -:   88:        int status;
       18:   89:        if (waitpid(pids[i], &status, 0) != pids[i] || WEXITSTATUS(status) != 0) {
    #####:   90:            return 0;
        -:   91:        }
        -:   92:    }
        -:   93:
        6:   94:    free(pids);
        -:   95:
        6:   96:    make_file_with_mirror_matrix(mirror_paral_matrix, matrix->horizontal, filename);
        6:   97:    return 0;
        -:   98:}
        -:   99:
    #####:  100:void print_final_matrix(int *matrix, int horizontal) {
    #####:  101:    for (int i = 0; i < horizontal * 0.5 * horizontal; ++i) {
    #####:  102:        if (i % (horizontal) == 0)
    #####:  103:            printf("\n");
    #####:  104:        printf("%d ", matrix[i]);
        -:  105:    }
    #####:  106:}
        -:  107:
    #####:  108:void print_start_matrix(Matrix matrix) {
    #####:  109:    for (int i = 0; i < matrix.vertical / 2 + matrix.vertical % 2; ++i) {
    #####:  110:        for (int j = 0; j < matrix.horizontal; ++j)
    #####:  111:            printf("%d ", matrix.array[i][j]);
    #####:  112:        printf("\n");
        -:  113:    }
    #####:  114:    for (int i = matrix.vertical / 2 - 1; i >= 0; --i) {
    #####:  115:        for (int j = matrix.horizontal; j < matrix.horizontal * 2; ++j)
    #####:  116:            printf("%d ", matrix.array[i][j]);
    #####:  117:        printf("\n");
        -:  118:    }
    #####:  119:    printf("\n\n");
    #####:  120:}
        -:  121:
        5:  122:int make_file_start_matrix(Matrix matrix, const char *filename) {
        5:  123:    if (!filename)
    #####:  124:        return 1;
        5:  125:    const char *mode = "w+";
        -:  126:
        5:  127:    FILE *file = fopen(filename, mode);
        5:  128:    if (!file)
    #####:  129:        return 1;
      255:  130:    for (int i = 0; i < matrix.horizontal * matrix.vertical; ++i) {
      250:  131:        fprintf(file, "%4d", rand() % 100);
        -:  132:    }
        5:  133:    if (fclose(file)) {
    #####:  134:        return 1;
        -:  135:    }
        5:  136:    return 0;
        -:  137:}
        -:  138:
        6:  139:int make_file_with_mirror_matrix(int *matrix, int horizontal, const char *filename) {
        6:  140:    if (!filename)
    #####:  141:        return 1;
        -:  142:
        6:  143:    FILE *f = fopen(filename, "wb");
        6:  144:    if (!f)
    #####:  145:        return 1;
        -:  146:
      306:  147:    for (int i = 0; i < horizontal * horizontal * 0.5; ++i) {
      300:  148:        fprintf(f, "%4d", matrix[i]);
        -:  149:    }
        -:  150:
        6:  151:    if (fclose(f))
    #####:  152:        return 1;
        -:  153:
        6:  154:    return 0;
        -:  155:}
        -:  156:
        6:  157:Matrix *create_matrix(int *horizontal, int *vertical) {
        6:  158:    if (!horizontal || !vertical) {
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:
        6:  162:    Matrix *m = (Matrix *) malloc(sizeof(Matrix));
        6:  163:    if (!m)
    #####:  164:        return NULL;
        -:  165:
        6:  166:    m->horizontal = *horizontal;
        6:  167:    m->vertical = *vertical;
        6:  168:    m->array = (int **) malloc((m->vertical / 2 + m->vertical % 2) * sizeof(int *));
        6:  169:    if (!m->array)
    #####:  170:        return NULL;
        -:  171:
       24:  172:    for (int i = 0; i < m->vertical / 2 + m->vertical % 2; i++) {
       18:  173:        m->array[i] = (int *) malloc(m->horizontal * 2 * sizeof(int));
       18:  174:        if (!m->array[i])
    #####:  175:            return NULL;
        -:  176:    }
        6:  177:    return m;
        -:  178:}
        -:  179:
        6:  180:int read_and_fill_matrix(Matrix matrix, const char *filename) {
        6:  181:    int temp = 0;
        6:  182:    FILE *f = fopen(filename, "rt");
        6:  183:    if (!f)
    #####:  184:        return 1;
       24:  185:    for (int i = 0; i < matrix.vertical / 2 + (matrix.vertical % 2); ++i) {
      198:  186:        for (int j = 0; j < matrix.horizontal; ++j) {
      180:  187:            fscanf(f, "%d", &temp);
      180:  188:            matrix.array[i][j] = temp;
        -:  189:        }
        -:  190:    }
        -:  191:
       18:  192:    for (int i = matrix.vertical / 2 - 1; i >= 0; --i) {
      132:  193:        for (int j = matrix.horizontal; j < matrix.horizontal * 2; ++j) {
      120:  194:            fscanf(f, "%d", &temp);
      120:  195:            matrix.array[i][j] = temp;
        -:  196:        }
        -:  197:    }
        6:  198:    fclose(f);
        6:  199:    return 0;
        -:  200:}
        -:  201:
        6:  202:void free_matrix(Matrix *mart) {
        6:  203:    if (mart == NULL) {
    #####:  204:        return;
        -:  205:    }
        -:  206:
        6:  207:    if ((*mart).array == NULL) {
    #####:  208:        free(mart);
    #####:  209:        mart = NULL;
    #####:  210:        return;
        -:  211:    }
        -:  212:
       24:  213:    for (int i = 0; i < mart->vertical / 2 + mart->vertical % 2; i++) {
       18:  214:        free(mart->array[i]);
        -:  215:    }
        6:  216:    free(mart->array);
        6:  217:    free(mart);
        6:  218:    mart = NULL;
        -:  219:}
